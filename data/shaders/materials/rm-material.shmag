/**
 * Roughness-metallic material.
 * Based on https://github.com/KhronosGroup/glTF-WebGL-PBR
 *
 * It is using a Cook-Torrance Model to compute lighting.
 * @todo This first version does not use environment maps,
 * but just computes it for one light source.
 */

// The only thing that is shared between geometry and epiphany.
struct {
    float(8) opacity;   // This (8) means that the value can be stored on 8 bits,
    vec3(8) albedo;     // as we want to reduce the size of that structure at most.
    nvec3(16) normal;   // It is normalized, storing costs one less.
    float(8) occlusion;
    float(8) roughness;
    float(8) metallic;
    vec3(8) emissive;
} gBuffer;

// ----- GEOMETRY

geometry {
    // Everything that the user can control,
    // with their default values.
    uniform {
        vec4 albedoColor = vec4(1, 1, 1, 1);
        float roughnessFactor = 1;
        float metallicFactor = 1;
        texture2d normalMap = "normal";
        texture2d albedoMap = "white";
        texture2d occlusionMap = "white";           // Red channel.
        texture2d roughnessMetallicMap = "white";   // Green and blue channels.
        texture2d emissiveMap = "invisible";
    };

    // In the geometry main, our role is to fill the G-Buffer
    // with the useful data for lighting computation.
    bool main() {
        vec4 albedo = texture(albedoMap, uv);
        if (albedo.a == 0) discard;
        albedo = srgbToLinearFast(albedo) * albedoColor;

        vec3 emissive = srgbToLinearFast(texture(emissiveMap, uv).rgb);
        vec3 normal = 2 * texture(normalMap, uv).rgb - 1;
        float occlusion = texture(occlusionMap, uv).r;
        vec4 roughnessMetallic = texture(roughnessMetallicMap, uv);

        gBuffer.opacity = albedo.a;
        gBuffer.albedo = albedo.rgb;
        gBuffer.normal = normalize(tbn * normal);
        gBuffer.emissive = emissive;
        gBuffer.occlusion = occlusion;
        gBuffer.roughness = clamp(roughnessFactor * roughnessMetallic.g, 0.04, 1);
        gBuffer.metallic = clamp(metallicFactor * roughnessMetallic.b, 0, 1);

        // Returns whether the fragment is considered translucent.
        return albedo.a < 1.0;
    }
}

// ----- EPIPHANY

epiphany {
    struct RmPbrData {
        float roughness;        // Material roughness.
        vec3 n;                 // Normal vector.
        vec3 v;                 // View vector.
        float n_l;              // Angle (cosine) between normal and light vector.
        float n_v;              // Angle (cosine) between normal and view vector.
        float n_h;              // Angle (cosine) between normal and half vector.
        float v_h;              // Angle (cosine) between view and half vector.
        vec3 reflectance0;      // Full reflectance color (normal incidence angle).
        vec3 reflectance90;     // Reflectance color at grazing angle.
        vec3 diffuseColor;      // Color contribution from diffuse lighting.
    };

    /**
    * Basic Lambertian diffuse.
    * From https://archive.org/details/lambertsphotome00lambgoog.
    */
    vec3 diffuse(vec3 diffuseColor)
    {
        return diffuseColor / PI;
    }

    /**
    * The Fresnel reflectance term.
    * From https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf (Eq. 15).
    */
    vec3 specularReflection(RmPbrData pbr)
    {
        return pbr.reflectance0 + (pbr.reflectance90 - pbr.reflectance0) * pow(1.0 - pbr.v_h, 5.0);
    }

    /**
    * The specular geometric attenuation,
    * where rougher material will reflect less light back to the viewer.
    * From http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
    * with alphaRoughness from http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf.
    */
    float geometricOcclusion(RmPbrData pbr)
    {
        float n_l = pbr.n_l;
        float n_v = pbr.n_v;
        float r2 = pbr.roughness * pbr.roughness;

        float attenuationL = 2.0 * n_l / (n_l + sqrt(r2 + (1.0 - r2) * n_l * n_l));
        float attenuationV = 2.0 * n_v / (n_v + sqrt(r2 + (1.0 - r2) * n_v * n_v));
        return attenuationL * attenuationV;
    }

    /**
    * The distribution of microfacet normals across the area being drawn.
    * From "Average Irregularity Representation of a Roughened Surface for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
    * and the distribution from http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf (Eq. 3).
    */
    float microfacetDistribution(RmPbrData pbr)
    {
        float r2 = pbr.roughness * pbr.roughness;
        float f = (r2 - 1.0) * pbr.n_h * pbr.n_h + 1.0;
        return r2 / (PI * f * f);
    }

    /**
    * Contribution for a single light.
    */
    vec3 lightContribution(vec3 position, RmPbrData pbr, inout float shadow)
    {
        vec3 l;
        float lightIntensity;
        if (!epiphanyLight(position, l, lightIntensity)) {
            return vec3(-1);
        }

        shadow = max(shadow, epiphanyLightShadow(l, position, pbr.n));

        // ----- Pre-computing

        vec3 h = normalize(l + pbr.v);
        pbr.n_l = clamp(dot(pbr.n, l), 0.001, 1.0);
        pbr.n_h = clamp(dot(pbr.n, h), 0.0, 1.0);
        pbr.v_h = clamp(dot(pbr.v, h), 0.0, 1.0);

        // @todo Have light color uniform
        vec3 lightColor = vec3(1);
        float lightEnergy = lightIntensity * pbr.n_l;

        // ----- BRDF

        // Calculate the shading terms for the microfacet specular shading model
        vec3 F = specularReflection(pbr);
        float G = geometricOcclusion(pbr);
        float D = microfacetDistribution(pbr);

        // Reflectance (BRDF) scaled by the energy of the light.
        vec3 diffuseContrib = (1.0 - F) * diffuse(pbr.diffuseColor);
        vec3 specularContrib = F * G * D / (4.0 * pbr.n_l * pbr.n_v);

        return lightEnergy * lightColor * (diffuseContrib + specularContrib);
    }

    vec4 main() {
        // ----- Common variables

        vec3 position = positionFromDepth(fragmentDepth, fragmentPosition);

        RmPbrData pbr;
        pbr.n = gBuffer.normal;
        pbr.v = normalize(camera.position.xyz - position);
        pbr.n_v = clamp(abs(dot(pbr.n, pbr.v)), 0.001, 1.0);

        // @note Convert to material roughness by squaring the perceptual roughness.
        pbr.roughness = gBuffer.roughness * gBuffer.roughness;

        // ----- Diffuse

        const vec3 f0 = vec3(0.04);
        pbr.diffuseColor = gBuffer.albedo * (1.0 - f0);
        pbr.diffuseColor *= (1.0 - gBuffer.metallic);

        // ----- Specular

        vec3 specularColor = mix(f0, gBuffer.albedo, gBuffer.metallic);

        // ----- Reflectance

        // For typical incident reflectance range (between 4% to 100%),
        // set the grazing reflectance to 100% for typical fresnel effect.
        // For very low reflectance range on highly diffuse objects (below 4%),
        // incrementally reduce grazing reflecance to 0%.
        float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
        float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
        pbr.reflectance0 = specularColor;
        pbr.reflectance90 = vec3(reflectance90);

        // ----- Lights contribution

        vec3 color = vec3(0);

        // @todo Iterate over all lights
        float shadow = 0;
        vec3 lightContributionColor = lightContribution(position, pbr, shadow);
        if (lightContributionColor.x >= 0) {
            color += lightContributionColor;
        }

        // ----- Occlusion

        color *= gBuffer.occlusion;

        // ----- Shadow

        color *= (1.0 - shadow);

        // ----- Emissive

        color += gBuffer.emissive;

        return vec4(linearToSrgb(color), gBuffer.opacity);
    }
}
