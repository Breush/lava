// Roughness-metallic material.

/**
 *  Input
 *  -----
 *
 *  data[0].x   -   roughnessFactor
 *  data[1].x   -   metallicFactor
 *
 *  sampler[0]  -   tNormalSampler
 *  sampler[1]  -   albedoSampler
 *  sampler[2]  -   ormSampler
 *  sampler[3]  -   reflectionSampler
 */

@magma:impl:begin geometry

#define PI 3.14159265358979323846

void @magma:impl:main (inout GBufferNode node) {
    vec3 normal = 2 * texture(samplers[0], inUv).rgb - 1;
    normal = normalize(inTbn * normal);

    vec4 albedo = texture(samplers[1], inUv);

    vec4 orm = texture(samplers[2], inUv);

    float occlusion = 1;
    occlusion *= orm.r;

    float roughness = uintBitsToFloat(material.data[0].x);
    roughness *= orm.g;

    float metallic = uintBitsToFloat(material.data[1].x);
    metallic *= orm.b;

    uint startIndex = 0;
    gBufferPackFloat(node, startIndex, albedo.a);
    gBufferPackVec3(node, startIndex, albedo.rgb);
    gBufferPackVec3Normalized(node, startIndex, normal);
    gBufferPackFloat(node, startIndex, occlusion);
    gBufferPackFloat(node, startIndex, roughness);
    gBufferPackFloat(node, startIndex, metallic);
}

@magma:impl:end geometry

@magma:impl:begin epiphany

// D = Normal distribution (Distribution of the microfacets)
float D_GGX(float dotNH, float roughness)
{
	float alpha = roughness * roughness;
	float alpha2 = alpha * alpha;
	float denom = dotNH * dotNH * (alpha2 - 1.0) + 1.0;
	return alpha2 / (PI * denom * denom); 
}

// G = Geometric shadowing term (Microfacets shadowing)
float G_SchlicksmithGGX(float dotNL, float dotNV, float roughness)
{
	float r = (roughness + 1.0);
	float k = (r*r) / 8.0;
	float GL = dotNL / (dotNL * (1.0 - k) + k);
	float GV = dotNV / (dotNV * (1.0 - k) + k);
	return GL * GV;
}

// F = Fresnel factor (Reflectance depending on angle of incidence)
vec3 F_Schlick(float cosTheta, vec3 F0)
{
	vec3 F = F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0); 
	return F;     
}

// Bidirectionnal reflectance distribution function
vec3 bdrf(vec3 L, vec3 V, vec3 N, vec3 F0, float roughness)
{
	// Precalculate vectors and dot products	
	vec3 H = normalize (V + L);
	float dotNV = clamp(dot(N, V), 0.0, 1.0);
	float dotNL = clamp(dot(N, L), 0.0, 1.0);
	float dotLH = clamp(dot(L, H), 0.0, 1.0);
	float dotNH = clamp(dot(N, H), 0.0, 1.0);

	// @todo Light color
	vec3 lightColor = vec3(1.0);

	vec3 color = vec3(0.0);

	if (dotNL > 0.0) {
		float rroughness = max(0.05, roughness);
		float D = D_GGX(dotNH, rroughness); 
		float G = G_SchlicksmithGGX(dotNL, dotNV, rroughness);
		vec3 F = F_Schlick(dotNV, F0);

		vec3 spec = D * F * G / (4.0 * dotNL * dotNV);

		color += spec * dotNL * lightColor;
	}

	return color;
}

vec4 @magma:impl:main (GBufferNode node) {
    uint startIndex = 0;
    float opacity = gBufferUnpackFloat(node, startIndex);
    vec3 albedo = gBufferUnpackVec3(node, startIndex);
    vec3 normal = gBufferUnpackVec3Normalized(node, startIndex);
    float occlusion = gBufferUnpackFloat(node, startIndex);
    float roughness = gBufferUnpackFloat(node, startIndex);
    float metallic = gBufferUnpackFloat(node, startIndex);
    
    // Common variables
    vec3 wPosition = wPositionFromDepth(node.depth, inUv);
    vec3 cameraDirection = normalize(camera.wPosition.xyz - wPosition.xyz);

    // For each light
    vec3 diffuseColor = vec3(0);
    vec3 specularColor = vec3(0);

    // Check whether the lighting should have an effect
    vec3 lightColor = vec3(1); // @todo Have light color
    vec3 lightDirection = light.wPosition.xyz - wPosition.xyz;
    float lightDistance = length(lightDirection);
    lightDirection = normalize(lightDirection);
    if (lightDistance < light.radius) {
        float lightIntensity = 1 - (lightDistance * lightDistance) / (light.radius * light.radius);
        lightIntensity *= 0.8; // @todo light.intensity

        vec3 F0 = mix(vec3(0.04), albedo, metallic);
        diffuseColor += lightIntensity * lightColor;
        specularColor += lightIntensity * bdrf(lightDirection, cameraDirection, normal, F0, roughness);
    }

    diffuseColor = vec3(0.2) + diffuseColor * 0.8; // @todo ambient light
    diffuseColor = clamp(diffuseColor, vec3(0), vec3(1));

    vec3 finalColor = occlusion * diffuseColor * albedo + specularColor;

    return vec4(finalColor, opacity);
}

@magma:impl:end epiphany

 