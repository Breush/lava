/**
 * Roughness-metallic material.
 * Based on https://github.com/KhronosGroup/glTF-WebGL-PBR
 *
 * It is using a Cook-Torrance Model to compute lighting.
 * @todo This first version does not use environment maps,
 * but just computes it for one light source.
 */


/**
 *  Input
 *  -----
 *
 *  data[0]     -   albedo color
 *  data[1].x   -   roughnessFactor
 *  data[2].x   -   metallicFactor
 *
 *  sampler[0]  -   tNormalSampler
 *  sampler[1]  -   albedoSampler
 *  sampler[2]  -   ormSampler
 *  sampler[3]  -   reflectionSampler
 */

@magma:impl:begin geometry

const float MIN_ROUGHNESS = 0.04;

bool @magma:impl:main (inout GBufferNode node) {
    vec3 normal = 2 * texture(samplers[0], inUv).rgb - 1;
    normal = normalize(inTbn * normal);

    uint startIndex = 0;
    vec4 albedoColor = materialUnpackVec4(startIndex);
    vec4 albedo = srgbToLinearFast(texture(samplers[1], inUv)) * albedoColor;
    if (albedo.a == 0) discard;

    vec4 orm = texture(samplers[2], inUv);

    float occlusion = 1;
    occlusion *= orm.r;

    float roughness = uintBitsToFloat(material.data[1].x);
    roughness *= orm.g;
    roughness = clamp(roughness, MIN_ROUGHNESS, 1.0);

    float metallic = uintBitsToFloat(material.data[2].x);
    metallic *= orm.b;
    metallic = clamp(metallic, 0.0, 1.0);

    startIndex = 0;
    gBufferPackFloat(node, startIndex, albedo.a);
    gBufferPackVec3(node, startIndex, albedo.rgb);
    gBufferPackVec3Normalized(node, startIndex, normal);
    gBufferPackFloat(node, startIndex, occlusion);
    gBufferPackFloat(node, startIndex, roughness);
    gBufferPackFloat(node, startIndex, metallic);

    return albedo.a < 1.0;
}

@magma:impl:end geometry

@magma:impl:begin epiphany

struct RmPbrData {
    float roughness;        // Material roughness.
    vec3 n;                 // Normal vector.
    vec3 v;                 // View vector.
    float n_l;              // Angle (cosine) between normal and light vector.
    float n_v;              // Angle (cosine) between normal and view vector.
    float n_h;              // Angle (cosine) between normal and half vector.
    float v_h;              // Angle (cosine) between view and half vector.
    vec3 reflectance0;      // Full reflectance color (normal incidence angle).
    vec3 reflectance90;     // Reflectance color at grazing angle.
    vec3 diffuseColor;      // Color contribution from diffuse lighting.
};

/**
 * Basic Lambertian diffuse.
 * From https://archive.org/details/lambertsphotome00lambgoog.
 */
vec3 diffuse(vec3 diffuseColor)
{
    return diffuseColor / PI;
}

/**
 * The Fresnel reflectance term.
 * From https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf (Eq. 15).
 */
vec3 specularReflection(RmPbrData pbr)
{
    return pbr.reflectance0 + (pbr.reflectance90 - pbr.reflectance0) * pow(1.0 - pbr.v_h, 5.0);
}

/**
 * The specular geometric attenuation,
 * where rougher material will reflect less light back to the viewer.
 * From http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
 * with alphaRoughness from http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf.
 */
float geometricOcclusion(RmPbrData pbr)
{
    float n_l = pbr.n_l;
    float n_v = pbr.n_v;
    float r2 = pbr.roughness * pbr.roughness;

    float attenuationL = 2.0 * n_l / (n_l + sqrt(r2 + (1.0 - r2) * n_l * n_l));
    float attenuationV = 2.0 * n_v / (n_v + sqrt(r2 + (1.0 - r2) * n_v * n_v));
    return attenuationL * attenuationV;
}

/**
 * The distribution of microfacet normals across the area being drawn.
 * From "Average Irregularity Representation of a Roughened Surface for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
 * and the distribution from http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf (Eq. 3).
 */
float microfacetDistribution(RmPbrData pbr)
{
    float r2 = pbr.roughness * pbr.roughness;
    float f = (r2 - 1.0) * pbr.n_h * pbr.n_h + 1.0;
    return r2 / (PI * f * f);
}

/**
 * Contribution for a single light.
 */
vec3 lightContribution(vec3 wPosition, RmPbrData pbr, out float shadow)
{
    shadow = 0;

    vec3 l;
    float lightIntensity;
    if (!epiphanyLight(wPosition, l, lightIntensity)) {
        return vec3(-1);
    }

    shadow = epiphanyLightShadow(l, wPosition, pbr.n);

    // ----- Pre-computing

    vec3 h = normalize(l + pbr.v);
    pbr.n_l = clamp(dot(pbr.n, l), 0.001, 1.0);
    pbr.n_h = clamp(dot(pbr.n, h), 0.0, 1.0);
    pbr.v_h = clamp(dot(pbr.v, h), 0.0, 1.0);

    // @todo Have light color uniform
    vec3 lightColor = vec3(1);
    float lightEnergy = lightIntensity * pbr.n_l;

    // ----- BRDF

    // Calculate the shading terms for the microfacet specular shading model
    vec3 F = specularReflection(pbr);
    float G = geometricOcclusion(pbr);
    float D = microfacetDistribution(pbr);

    // Reflectance (BRDF) scaled by the energy of the light.
    vec3 diffuseContrib = (1.0 - F) * diffuse(pbr.diffuseColor);
    vec3 specularContrib = F * G * D / (4.0 * pbr.n_l * pbr.n_v);

    return lightEnergy * lightColor * (diffuseContrib + specularContrib);
}

vec4 @magma:impl:main (GBufferNode node) {
    uint startIndex = 0;
    float opacity = gBufferUnpackFloat(node, startIndex);
    vec3 albedo = gBufferUnpackVec3(node, startIndex);
    vec3 normal = gBufferUnpackVec3Normalized(node, startIndex);
    float occlusion = gBufferUnpackFloat(node, startIndex);
    float roughness = gBufferUnpackFloat(node, startIndex);
    float metallic = gBufferUnpackFloat(node, startIndex);

    // ----- Common variables

    vec3 wPosition = wPositionFromDepth(node.depth, inUv);

    RmPbrData pbr;
    pbr.n = normal;
    pbr.v = normalize(camera.wPosition.xyz - wPosition);
    pbr.n_v = clamp(abs(dot(normal, pbr.v)), 0.001, 1.0);

    // @note Convert to material roughness by squaring the perceptual roughness.
    pbr.roughness = roughness * roughness;

    // ----- Diffuse

    const vec3 f0 = vec3(0.04);
    pbr.diffuseColor = albedo * (1.0 - f0);
    pbr.diffuseColor *= (1.0 - metallic);

    // ----- Specular

    vec3 specularColor = mix(f0, albedo, metallic);

    // ----- Reflectance

    // For typical incident reflectance range (between 4% to 100%),
    // set the grazing reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%),
    // incrementally reduce grazing reflecance to 0%.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    pbr.reflectance0 = specularColor;
    pbr.reflectance90 = vec3(reflectance90);

    // ----- Lights contribution

    vec3 color = vec3(0);

    // @todo Iterate over all lights
    float shadow;
    vec3 lightContributionColor = lightContribution(wPosition, pbr, shadow);
    if (lightContributionColor.x >= 0) {
        color += lightContributionColor;
    }

    // ----- Occlusion

    color *= occlusion;

    // ----- Emissive

    // @todo Implement emissive

    // ----- Shadow

    color *= (1.0 - shadow);

    return vec4(linearToSrgb(color), opacity);
}

@magma:impl:end epiphany

