//----- Unpacking

float gBufferUnpackFloat(GBufferNode node, inout uint startIndex) {
    float value = uintBitsToFloat(node.materialData[startIndex++]);
    return value;
}

vec3 gBufferUnpackVec3(GBufferNode node, inout uint startIndex) {
    vec3 value;
    value.x = uintBitsToFloat(node.materialData[startIndex++]);
    value.y = uintBitsToFloat(node.materialData[startIndex++]);
    value.z = uintBitsToFloat(node.materialData[startIndex++]);
    return value;
}

// Stored using spherical coordinates
vec3 gBufferUnpackVec3Normalized(GBufferNode node, inout uint startIndex) {
    float phi = uintBitsToFloat(node.materialData[startIndex++]);
    float theta = uintBitsToFloat(node.materialData[startIndex++]);
    
    vec3 value;
    value.x = sin(phi) * cos(theta);
    value.y = sin(phi) * sin(theta);
    value.z = cos(phi);
    return value;
}

vec4 gBufferUnpackVec4(GBufferNode node, inout uint startIndex) {
    vec4 value;
    value.x = uintBitsToFloat(node.materialData[startIndex++]);
    value.y = uintBitsToFloat(node.materialData[startIndex++]);
    value.z = uintBitsToFloat(node.materialData[startIndex++]);
    value.w = uintBitsToFloat(node.materialData[startIndex++]);
    return value;
}

//----- Lights

// @note The lightDirection is defined as the normalized vector
// from the fragment to the light source.
bool epiphanyLight(vec3 wPosition, out vec3 lightDirection, out float lightIntensity) {
    lightIntensity = 0;

    switch (light.type) {
        // Point light
        case 0: {
            lightDirection = light.wPosition.xyz - wPosition;
            float lightDistance = length(lightDirection);

            float radius = uintBitsToFloat(light.data[0].x);
            if (lightDistance < radius) {
                lightIntensity = 1 - (lightDistance * lightDistance) / (radius * radius);
            }
            break;
        }

        // Directional light
        case 1: {
            lightDirection.x = -uintBitsToFloat(light.data[0].x);
            lightDirection.y = -uintBitsToFloat(light.data[0].y);
            lightDirection.z = -uintBitsToFloat(light.data[0].z);

            // @todo Have that settable
            lightIntensity = 1;

            break;
        }

        default: {
            return false;
        }
    }

    lightDirection = normalize(lightDirection);
    return true;
}

// position and normal are the fragment's attributes.
float epiphanyLightShadow(vec3 lightDirection, vec3 position, vec3 normal)
{
    if (light.type == LIGHT_TYPE_DIRECTIONAL) {
        // Unproject the current fragment world-position
        // to find the corresponding pixel to pick in the shadow map
        vec4 nodeLightSpacePosition = light.transform * vec4(position, 1);
        vec2 lightUv = (nodeLightSpacePosition.xy + 1) / 2;

        // Bias
        float n_l = dot(normal, lightDirection);
        float bias = clamp(0.005 * tan(acos(n_l)), 0.0, 0.01);

        float shadowsDepth = texture(lightShadowsSampler, lightUv).r;
        float fragmentLightSpaceDepth = nodeLightSpacePosition.z;
        if (shadowsDepth > 0 && shadowsDepth + bias < fragmentLightSpaceDepth) {
            return 0.5;
        }
    }

    return 0.0;
}
