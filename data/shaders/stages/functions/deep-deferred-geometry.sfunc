//----- Material data unpacking

vec4 materialUnpackVec4(inout uint startIndex) {
    vec4 value;
    value.x = uintBitsToFloat(material.data[startIndex].x);
    value.y = uintBitsToFloat(material.data[startIndex].y);
    value.z = uintBitsToFloat(material.data[startIndex].z);
    value.w = uintBitsToFloat(material.data[startIndex].w);
    startIndex += 1;
    return value;
}

//----- Packing

void gBufferPackFloat(inout GBufferNode node, inout uint startIndex, float value) {
    node.materialData[startIndex++] = floatBitsToUint(value);
}

// @fixme If the vec3 comes from a 8bits channel, we could store that
// with very less memory (3 bytes only, instead of 12).
void gBufferPackVec3(inout GBufferNode node, inout uint startIndex, vec3 value) {
    node.materialData[startIndex++] = floatBitsToUint(value.x);
    node.materialData[startIndex++] = floatBitsToUint(value.y);
    node.materialData[startIndex++] = floatBitsToUint(value.z);
}

// Stored using spherical coordinates
void gBufferPackVec3Normalized(inout GBufferNode node, inout uint startIndex, vec3 value) {
    float phi = acos(value.z);
    float theta = atan(value.y, value.x);

    node.materialData[startIndex++] = floatBitsToUint(phi);
    node.materialData[startIndex++] = floatBitsToUint(theta);
}

void gBufferPackVec4(inout GBufferNode node, inout uint startIndex, vec4 value) {
    node.materialData[startIndex++] = floatBitsToUint(value.x);
    node.materialData[startIndex++] = floatBitsToUint(value.y);
    node.materialData[startIndex++] = floatBitsToUint(value.z);
    node.materialData[startIndex++] = floatBitsToUint(value.w);
}
